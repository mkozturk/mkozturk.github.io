<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Kaan Öztürk">
<meta name="dcterms.date" content="2023-11-25">
<meta name="description" content="Algoritmalarınızı scikit-learn yapısına uygun olarak yazın ve bu zengin kütüphanenin gücünü tam olarak kullanın">

<title>Kaan Öztürk - Scikit-learn ile Kendi Tahminleyicilerimizi Yazmak</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-5PQNVMN09N"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-5PQNVMN09N', { 'anonymize_ip': true});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../../../styles.css">
<meta name="twitter:title" content="Kaan Öztürk - Scikit-learn ile Kendi Tahminleyicilerimizi Yazmak">
<meta name="twitter:description" content="Algoritmalarınızı scikit-learn yapısına uygun olarak yazın ve bu zengin kütüphanenin gücünü tam olarak kullanın">
<meta name="twitter:image" content="https://mkozturk.com/posts/tr/2023/scikit-tahminleyici-yazmak/scikit-learn-logo.png">
<meta name="twitter:image-height" content="165">
<meta name="twitter:image-width" content="306">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../../../index.html">
    <span class="navbar-title">Kaan Öztürk</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../index.html" rel="" target="">
 <span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../blog.html" rel="" target="">
 <span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../../../blog.xml" rel="" target=""><i class="bi bi-rss" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Scikit-learn ile Kendi Tahminleyicilerimizi Yazmak</h1>
                  <div>
        <div class="description">
          Algoritmalarınızı scikit-learn yapısına uygun olarak yazın ve bu zengin kütüphanenin gücünü tam olarak kullanın
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">data science</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Kaan Öztürk </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">November 25, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#scikit-learn-arayüzü" id="toc-scikit-learn-arayüzü" class="nav-link active" data-scroll-target="#scikit-learn-arayüzü"><code>scikit-learn</code> arayüzü</a></li>
  <li><a href="#neden" id="toc-neden" class="nav-link" data-scroll-target="#neden">Neden?</a></li>
  <li><a href="#kestirim" id="toc-kestirim" class="nav-link" data-scroll-target="#kestirim">Kestirim</a></li>
  <li><a href="#standartlara-uyum-kontrolü" id="toc-standartlara-uyum-kontrolü" class="nav-link" data-scroll-target="#standartlara-uyum-kontrolü">Standartlara uyum kontrolü</a></li>
  <li><a href="#sınıflandırma" id="toc-sınıflandırma" class="nav-link" data-scroll-target="#sınıflandırma">Sınıflandırma</a></li>
  <li><a href="#veri-dönüşümü" id="toc-veri-dönüşümü" class="nav-link" data-scroll-target="#veri-dönüşümü">Veri dönüşümü</a>
  <ul class="collapse">
  <li><a href="#hareketli-ortalama" id="toc-hareketli-ortalama" class="nav-link" data-scroll-target="#hareketli-ortalama">Hareketli ortalama</a></li>
  <li><a href="#minimum-maksimum-ölçekleme" id="toc-minimum-maksimum-ölçekleme" class="nav-link" data-scroll-target="#minimum-maksimum-ölçekleme">Minimum-maksimum ölçekleme</a></li>
  </ul></li>
  <li><a href="#pipeline-kullanımı" id="toc-pipeline-kullanımı" class="nav-link" data-scroll-target="#pipeline-kullanımı">Pipeline kullanımı</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block page-columns page-full" id="quarto-document-content">




<p>Python’la yapay öğrenme modelleri çalıştıran her veri bilimcinin aşina olduğu bir kütüphanedir <a href="https://scikit-learn.org/stable/"><code>scikit-learn</code></a>. Son derece zengin bir algoritma koleksiyonunu barındırır. Çoğu zaman o algoritmaları olduğu gibi kullanmak yeterlidir.</p>
<p>Ama bazen çok özelleşmiş bir algoritmaya ihtiyaç duyabilirsiniz. Bunu <code>scikit-learn</code> arayüzüne uygun şekilde yazarsanız, kütüphanenin sağladığı birçok başka kolaylığa da rahatça erişebilirsiniz.</p>
<p>Bu yazıda, kendi regresyon veya sınıflandırıcı modelinizi nasıl <code>scikit-learn</code> modülünün parçasıymış gibi yazabileceğinizi anlatacağım. Önce, <code>scikit-learn</code> sisteminin nasıl kullanıldığına bir bakalım.</p>
<section id="scikit-learn-arayüzü" class="level1">
<h1><code>scikit-learn</code> arayüzü</h1>
<p>Aşina olduğumuz <code>scikit-learn</code> yapısında üç aşama vardır: Tahminleyici nesnesini yaratmak, veriyle eğitmek, sonra eğitilmiş modelden tahmin üretmek. Mesela:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>knn <span class="op">=</span> KNeighborsClassifier()  <span class="co"># (1)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>knn.fit(X_train, y_train)     <span class="co"># (2)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>y_pred <span class="op">=</span> knn.predict(X_test)  <span class="co"># (3)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol type="1">
<li><code>scikit-learn</code> içindeki her algoritma bir <em>estimator</em> nesne sınıfı olarak kodlanmıştır. Regresyon, sınıflayıcı ve diğer tahminleyici türlerinin hepsi temel <code>BaseEstimator</code> sınıfından türetilmiştir.</li>
<li>Eğitme işi <code>fit()</code> metodu ile sağlanır. Buradaki eğitim, sözgelişi, regresyon parametrelerini belirlemek, PCA bileşenlerini hesaplamak, veya bir ölçekleme yapmakta kullanılacak parametreleri bulmak olabilir.</li>
<li>Eğitilen modeli kullanarak yeni veri ile kestirim yapmak için <code>predict()</code> metodu kullanılır.</li>
</ol>
<p>Bunlar en temel işlemler. Bunların yanı sıra, sınıflayıcı (classifier) tahminleyicilerde <code>predict_proba()</code> veye <code>decision_function()</code> metodları bulunabilir. Bunlar her bir tahmin sınıfı için evet/hayır cevabı yerine daha “yumuşak” puanlar sağlarlar. Ayrıca regresyon tahminleyicilerinde <code>score()</code> gibi başarı ölçüsü veren metotlar olabilir.</p>
<p>Bazı algoritmalar ise veriyi dönüştürme amaçlı kullanılırlar. Örneğin ölçekleme veya PCA işlemleri. Bu tür tahminleyicilerde <code>transform()</code> metodu bulunur.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>scaler <span class="op">=</span> StandardScaler()</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>scaler.fit(X_train)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>X_trf <span class="op">=</span> scaler.transform(X_train)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Bir çok durumda birkaç tahminleyici ve dönüştürücü birbirlerinin ardı sıra eklenerek kullanılırlar. <code>scikit-learn</code> bunu otomatikleştirmek için bir <code>Pipeline</code> (veri hattı) nesnesi sağlar. Bir <code>Pipeline</code> nesnesinin kendine ait <code>fit()</code> ve <code>predict()</code> metodları bulunur, böylece kendi başına bir tahminleyici imiş gibi kullanılabilir.</p>
<p>Örneğin, aşağıdaki adımlar, verinin önce ölçeklenip sonra k-NN ile sınıflandırıldığı bir işlem sağlar.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>pipe <span class="op">=</span> Pipeline(steps<span class="op">=</span>[(<span class="st">'scale'</span>, StandardScaler), (<span class="st">'knn'</span>, knn)])</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>pipe.fit(X_train, y_train)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>y_pred <span class="op">=</span> pipe.predict(X_test)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Yeni bir tahminleyici yazacağımız zaman, burada özetlenen arayüzle tutarlı olmasını isteriz. <code>scikit-learn</code> bize bunun için bir standart ve ona uymak için kullanılacak araçlar sunuyor.</p>
<div class="callout callout-style-default callout-note callout-titled" title="Resmi belgeler">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Resmi belgeler
</div>
</div>
<div class="callout-body-container callout-body">
<p>Buradaki örnekler ve açıklamalar kaçınılmaz olarak eksik kalacak. Tam bir başvuru kaynağı olarak resmi dökümantasyona (<a href="https://scikit-learn.org/stable/developers/develop.html">Developing scikit-learn estimators</a>) bakabilirsiniz.</p>
</div>
</div>
</section>
<section id="neden" class="level1">
<h1>Neden?</h1>
<p>Neden tahminleyici algoritmamızı <code>scikit-learn</code> yapısına uydurmak için uğraşalım? Eğitim ve kestirim adımlarını iki ayrı fonksiyon halinde tutmakla, veya tek bir nesne sınıfı yaratıp içine <code>fit()</code> ve <code>predict()</code> metotlarını koymakla niye yetinmeyelim? Haklı sorular.</p>
<p><code>scikit-learn</code> standardına uymanın en bariz yararı, kütüphanenin sunduğu üst seviye araçları kolayca kullanabilme imkânı. Örneğin, algoritmanız önceden verilerin ölçeklenmesini gerektiriyorsa, bunu kendiniz kodlamak zorunda kalmazsınız. <code>scikit-learn</code> içinde bulunan dönüştürücü ile beraber bir pipeline kurabilirsiniz.</p>
<p>Keza <code>scikit-learn</code> içindeki çapraz doğrulama (cross-validation), parametre uzayı tarama (grid search) gibi işlemleri de kolayca yapabilirsiniz. Otomatik model seçme işlemlerine kendi algoritmanızı pürüzsüz bir şekilde entegre edebilirsiniz.</p>
<p>Üstelik, içinde <code>fit()</code> ve <code>predict()</code> metotları bulunan bir nesne sınıfı yaptıktan sonra, bunu <code>scikit-learn</code> standardına uygun hale getirmenin zahmetsiz bir iş olduğunu göreceğiz. Yani az bir çabayla, büyük bir güç elde ediyoruz.</p>
<div class="callout callout-style-default callout-tip callout-titled" title="Kod kalıpları">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Kod kalıpları
</div>
</div>
<div class="callout-body-container callout-body">
<p>Yeni tahminleyiciler geliştirirken örnek alabileceğiniz <a href="https://github.com/scikit-learn-contrib/project-template">kod kalıpları mevcut</a>. Sıfırdan başlamak yerine uygun bir kalıbı alıp içini uygun şekilde doldurabilirsiniz.</p>
</div>
</div>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tekerleği baştan icat etmeyin
</div>
</div>
<div class="callout-body-container callout-body">
<p>İstediğiniz dönüşümü yapabilen bir <code>scikit-learn</code> fonksiyonu varsa onu kullanın. Kütüphanenin dökümantasyonuna göz gezdirin, aşina olun.</p>
</div>
</div>
</section>
<section id="kestirim" class="level1">
<h1>Kestirim</h1>
<p>İlk örnek olarak, regresyon kestirimi yapan bir sınıf yaratalım. Algoritmik ayrıntılara boğulmamak için basit tutalım: Tahmin olarak eğitim kümesinin ortalamasını veya ortancasını veren bir kestirici olsun.</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.base <span class="im">import</span> BaseEstimator, RegressorMixin</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.utils <span class="im">import</span> check_X_y, check_array</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.utils.validation <span class="im">import</span> check_is_fitted</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SimpleRegressor(BaseEstimator, RegressorMixin):   <span class="co"># (1)</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, method<span class="op">=</span><span class="st">"mean"</span>):                  <span class="co"># (2)</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.method <span class="op">=</span> method</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> fit(<span class="va">self</span>, X, y):                                <span class="co"># (3)</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.method <span class="kw">not</span> <span class="kw">in</span> [<span class="st">"mean"</span>, <span class="st">"median"</span>]:       <span class="co"># (4)</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"method must be 'mean' or 'median'"</span>)</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        X, y <span class="op">=</span> check_X_y(X, y)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.method<span class="op">==</span><span class="st">"mean"</span>:</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.coef_ <span class="op">=</span> np.mean(y)                     </span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.method<span class="op">==</span><span class="st">"median"</span>:</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.coef_ <span class="op">=</span> np.median(y)                   <span class="co"># (5)</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n_features_in_ <span class="op">=</span> X.shape[<span class="dv">1</span>]</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>                                     <span class="co"># (6)</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> predict(<span class="va">self</span>, X):</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>        X <span class="op">=</span> check_array(X)                              <span class="co"># (7)</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>        check_is_fitted(<span class="va">self</span>, attributes<span class="op">=</span>[<span class="st">"coef_"</span>])</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.ones(X.shape[<span class="dv">0</span>])<span class="op">*</span><span class="va">self</span>.coef_           <span class="co"># (8)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Bunu satır satır açıklayalım.</p>
<p><strong>(1) Miras alınan sınıflar</strong><br>
Kestirici sınıfımıza <code>SimpleRegressor</code> adını veriyoruz. Bu sınıf <code>BaseEstimator</code> sınıfında tanımlanmış elemanları miras alıyor. Ayrıca <code>RegressorMixin</code> sınıfını ebeveyn olarak ekliyoruz. Böylece hem bunun bir regresyon kestiricisi olarak tanınmasını, hem de <code>score()</code> metodunun miras alınmasını sağlıyor.</p>
<p><strong>(2) Başlatıcı</strong><br>
Sınıf inşacısının (constructor) basit olması istenir. Kestiriciyi çağırırken, algoritmayla ilgili hiperparametreleri burada veririz.</p>
<p>Dikkat edilecek noktalar:</p>
<ul>
<li>Her parametre, kendisiyle tıpatıp aynı isimde bir nesne değişkenine dönüştürülmelidir (<code>method</code> ve <code>self.method</code> gibi). Tahminleyicilerin <code>get_param()</code> ve <code>set_param()</code> metodlarının doğru çalışması buna bağlıdır.</li>
<li>Bütün parametrelerin varsayılan (default) değerleri olmalıdır. Bir tahminleyici hiç bir parametre verilmeden de makul bir şekilde çalışabilmeli. Örneğin <code>reg = SimpleRegressor()</code>.</li>
<li>Veri denetlemesi veya hata düzeltmesi gibi işlemler sadece <code>fit()</code> içinde yapılmalıdır. <code>__init__</code> içinde atama dışında bir işlem bulunmamalıdır. Aksi takdirde, hiperparametre ataması için kullanılan <code>set_param()</code> gibi alternatif yollar (mesela grid search işleminde) doğru çalışmaz.</li>
</ul>
<p><strong>(3) fit() metodu</strong><br>
Bu metodun her zaman <code>X</code> (veri matrisi) ve <code>y</code> (hedef değer vektörü) alması gerekir.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Gözetimsiz (unsupervised) algoritmalarda <code>y</code> alınması gerekmez, yine de API tutarlılığı açısından parametre listesinde bulunur, varsayılan değer olarak <code>None</code> atanır: <code>def fit(self, X, y=None)</code>.</p>
</div>
</div>
<p><strong>(4) Doğrulama kontrolleri</strong><br>
Hiperparametrelerin doğru aralıkta olması, verilerin uygun biçimde olması gibi testler burada yapılmalıdır. Bunun için <code>sklearn.utils</code> modülünde çeşitli fonksiyonlar mevcut. Burada <code>check_X_y</code> ile verilerin uygun biçim ve boyutta olduğunu kontrol ediyoruz.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Numpy kullanın
</div>
</div>
<div class="callout-body-container callout-body">
<p><code>scikit-learn</code> algoritmaları pandas veri tabloları alabilir, ama bunları kendi içinde Numpy dizilerine dönüştürür. Siz de tahminleyicilerinizi kodlarken sadece Numpy yapılarını kullanın.</p>
</div>
</div>
<p><strong>(5) Model parametreleri</strong> Seçilen yönteme göre, hedef vektörü <code>y</code>’nin ortalama veya ortancasını hesaplayıp, <code>coef_</code> isimli bir nesne değişkeninde tutuyoruz. Bu isim istediğiniz gibi seçilebilir. Birçok regresyon tahmincisi <code>coef_</code> kullandığı için biz de burada aynısını kullandık.</p>
<p>Veri kullanılarak hesaplanan değişkenlerin alt çizgiyle bitmesi gerekir.</p>
<p><code>n_features_in_</code> değişkeni veride kaç öznitelik olduğunun hesabını tutmamıza yarar. Kestirme için kullanılan verinin de aynı sayıda özniteliği olduğunu kontrol etmek için kullanılır.</p>
<p><strong>(6) <code>fit()</code> bir tahminleyici döndürür</strong><br>
<code>fit()</code> metodu her zaman <code>self</code> döndürmelidir. Böylece</p>
<p><code>y_pred = SimpleRegressor().fit(X_train, y_train).predict(X_test)</code></p>
<p>gibi metot zincirleri kurmak mümkün olur.</p>
<p><strong>(7) Kestirim aşaması kontrolleri</strong><br>
<code>check_array()</code> fonksiyonu girdinin uygun biçimde bir veri yapısı olup olmadığını denetler.</p>
<p>Tahminleyicinin <code>fit()</code> metodu bir kere çalıştırılıp model eğitilmeden kestirim yapmak anlamsız olacaktır. <code>check_is_fitted()</code> fonksiyonuyla bunun denetimini yaparız. Fonksiyon buradaki haliyle <code>coef_</code> değişkeninin mevcut olup olmadığına bakar. <code>attributes</code> parametresini kullanmasaydık, altçizgi (<code>_</code>) ile biten herhangi bir değişken olup olmadığını kontrol ederdi.</p>
<p><strong>(8) <code>predict()</code> bir dizi (array) döndürür</strong><br>
Model tahmini için gerekli işlemler yapıldıktan sonra, test verisindeki satır sayısı uzunluğunda bir boyutlu bir dizi (array) elde ederiz.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Genel amaçlı tahminleyiciler yazın
</div>
</div>
<div class="callout-body-container callout-body">
<p>Özel bir probleme odaklanıyor olsanız da, çözümün işe yarar en genel halinin ne olabileceğini düşünün ve tahminleyicinizi ona göre yazın. Tahminleyicinizi bambaşka bir bağlam ve problemde de kullanılabilecek şekilde tasarlayın. Yazdığınız kod, veri hakkında çok fazla varsayıma bağlı olmasın. Veri biçimlendirme işlemlerini tahminleyiciye koymayın. Ya önceden yapın, ya da veri akış hattının başına ayrı bir işlem olarak koyun.</p>
</div>
</div>
<p>Şimdi bu kestiriciyi diğer <code>scikit-learn</code> kestiricileri gibi kullanabiliriz. Önce rastgele veri üretelim:</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">29101923</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>X_train, X_test <span class="op">=</span> np.random.rand(<span class="dv">10</span>,<span class="dv">2</span>), np.random.rand(<span class="dv">5</span>,<span class="dv">2</span>)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>y_train, y_test <span class="op">=</span> np.random.randn(<span class="dv">10</span>), np.random.randn(<span class="dv">5</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>y_train.mean(), np.median(y_train)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="2">
<pre><code>(0.3662107108568314, 0.2861502525347002)</code></pre>
</div>
</div>
<p>Basit regresyon tahminleyicimiz, eğitim kümesinin hedef değişkeninin ortalaması hesaplayacak ve her yeni kestirim için aynı değeri verecek:</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>SimpleRegressor().fit(X_train, y_train).predict(X_test)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="3">
<pre><code>array([0.36621071, 0.36621071, 0.36621071, 0.36621071, 0.36621071])</code></pre>
</div>
</div>
<p>Tahminleyicinin ortanca değer kullanmasını istersek:</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>SimpleRegressor(method<span class="op">=</span><span class="st">"median"</span>).fit(X_train, y_train).predict(X_test)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<pre><code>array([0.28615025, 0.28615025, 0.28615025, 0.28615025, 0.28615025])</code></pre>
</div>
</div>
<p><code>RegressorMixin</code> sınıfından miras alınan <code>score</code> metodunu kullanarak, kestirimimizin <span class="math inline">\(R^2\)</span> puanını hesaplatabiliriz.</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>SimpleRegressor().fit(X_train, y_train).score(X_test,y_test)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<pre><code>-0.6810225522666027</code></pre>
</div>
</div>
</section>
<section id="standartlara-uyum-kontrolü" class="level1">
<h1>Standartlara uyum kontrolü</h1>
<p>Yazdığımız tahminleyicinin <code>scikit-learn</code> standartlarına uyup uymadığını kontrol etmek için <code>utils.estimator_checks.check_estimator</code> fonksiyonunu kullanırız.</p>
<p><code>check_estimator</code>, yaptığı kontrollerin yanı sıra, mevcut veri kümelerinde tahminleyicimizin ne kadar isabetli olduğunu da test eder. Ancak, mecvut haliyle kestiricimiz testi geçemiyor:</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.utils.estimator_checks <span class="im">import</span> check_estimator</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>check_estimator(SimpleRegressor())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<pre><code>AssertionError                            Traceback (most recent call last)
...
   2277     if not regressor._get_tags()["poor_score"]:
-&gt; 2278         assert regressor.score(X, y_) &gt; 0.5
   2279 
   2280 

AssertionError: </code></pre>
<p>Bunun nedeni, çok basit bir kestirici yaratmış olmamız ve hatasının yüksek oluşu.</p>
<p>Kötü tahmin yapan bir kestiriciyi <code>scikit-learn</code>’e kabul ettirmek mümkün. Bunun için <em>estimator tag</em> özelliklerini kullanırız. Bu etiketlerin ne olduklarının açıklaması ve tam bir listesi için <a href="https://scikit-learn.org/stable/developers/develop.html#estimator-tags">belgelere bakabilirsiniz</a>. Buradaki amacımız için <em>poor_score</em> etiketini <code>True</code> değeriyle kestiricimize eklemeliyiz. Bunun için kestirici sınıfına <code>_more_tags</code> isimli bir metod eklemek gerekli.</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.utils.estimator_checks <span class="im">import</span> check_estimator</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _more_tags(<span class="va">self</span>):</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> {<span class="st">'poor_score'</span>: <span class="va">True</span>}</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>SimpleRegressor._more_tags <span class="op">=</span> _more_tags</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>check_estimator(SimpleRegressor())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Şimdi hiç bir hata mesajı almadık. Tahminleyicimiz testleri geçti.</p>
</section>
<section id="sınıflandırma" class="level1">
<h1>Sınıflandırma</h1>
<p>Şimdi de basit bir sınıflandırıcı (classifier) yaratalım. Her nokta için tahmin edilen sııf, ona en yakın komşusunun sınıfı olsun (1-NN algoritması).</p>
<p>Proje kalıpları içeren <a href="https://github.com/scikit-learn-contrib/project-template">project-template</a> reposunda tam da bu işi yapan bir kod kalıbı mevcut. Küçük değişikliklerle kullanalım:</p>
<div class="cell" data-execution_count="8">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.base <span class="im">import</span> BaseEstimator, ClassifierMixin</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.utils <span class="im">import</span> check_X_y, check_array</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.utils.validation <span class="im">import</span> check_is_fitted</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.utils.multiclass <span class="im">import</span> unique_labels</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> euclidean_distances</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TemplateClassifier(BaseEstimator,ClassifierMixin):</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">""" An example classifier which implements a 1-NN algorithm.</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="co">    For more information regarding how to build your own classifier, read more</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a><span class="co">    in the User Guide.</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a><span class="co">    demo_param : str, default='demo'</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a><span class="co">        A parameter used for demonstation of how to pass and store parameters.</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a><span class="co">    Attributes</span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a><span class="co">    X_ : ndarray, shape (n_samples, n_features)</span></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a><span class="co">        The input passed during fit().</span></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a><span class="co">    y_ : ndarray, shape (n_samples,)</span></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a><span class="co">        The labels passed during fit().</span></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a><span class="co">    classes_ : ndarray, shape (n_classes,)</span></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a><span class="co">        The classes seen at fit().</span></span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a><span class="co">    Examples</span></span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a><span class="co">    --------</span></span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a><span class="co">    &gt;&gt;&gt; X = [[0, 0], [1, 1]]</span></span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a><span class="co">    &gt;&gt;&gt; y = [0, 1]</span></span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a><span class="co">    &gt;&gt;&gt; clf = TemplateClassifier()</span></span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a><span class="co">    &gt;&gt;&gt; clf.fit(X, y)</span></span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a><span class="co">    &gt;&gt;&gt; rng = np.random.RandomState(13)</span></span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true" tabindex="-1"></a><span class="co">    &gt;&gt;&gt; X_test = [[0.2,0.2], [0.4,0.4], [0.6, 0.6], [0.8, 0.8]]</span></span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true" tabindex="-1"></a><span class="co">    &gt;&gt;&gt; clf.predict(X_test)</span></span>
<span id="cb16-37"><a href="#cb16-37" aria-hidden="true" tabindex="-1"></a><span class="co">    array([0, 0, 1, 1])</span></span>
<span id="cb16-38"><a href="#cb16-38" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb16-39"><a href="#cb16-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, demo_param<span class="op">=</span><span class="st">'demo'</span>):</span>
<span id="cb16-40"><a href="#cb16-40" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.demo_param <span class="op">=</span> demo_param</span>
<span id="cb16-41"><a href="#cb16-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-42"><a href="#cb16-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> fit(<span class="va">self</span>, X, y):</span>
<span id="cb16-43"><a href="#cb16-43" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""A reference implementation of a fitting function for a classifier.</span></span>
<span id="cb16-44"><a href="#cb16-44" aria-hidden="true" tabindex="-1"></a><span class="co">        Parameters</span></span>
<span id="cb16-45"><a href="#cb16-45" aria-hidden="true" tabindex="-1"></a><span class="co">        ----------</span></span>
<span id="cb16-46"><a href="#cb16-46" aria-hidden="true" tabindex="-1"></a><span class="co">        X : array-like, shape (n_samples, n_features)</span></span>
<span id="cb16-47"><a href="#cb16-47" aria-hidden="true" tabindex="-1"></a><span class="co">            The training input samples.</span></span>
<span id="cb16-48"><a href="#cb16-48" aria-hidden="true" tabindex="-1"></a><span class="co">        y : array-like, shape (n_samples,)</span></span>
<span id="cb16-49"><a href="#cb16-49" aria-hidden="true" tabindex="-1"></a><span class="co">            The target values. An array of int.</span></span>
<span id="cb16-50"><a href="#cb16-50" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns</span></span>
<span id="cb16-51"><a href="#cb16-51" aria-hidden="true" tabindex="-1"></a><span class="co">        -------</span></span>
<span id="cb16-52"><a href="#cb16-52" aria-hidden="true" tabindex="-1"></a><span class="co">        self : object</span></span>
<span id="cb16-53"><a href="#cb16-53" aria-hidden="true" tabindex="-1"></a><span class="co">            Returns self.</span></span>
<span id="cb16-54"><a href="#cb16-54" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb16-55"><a href="#cb16-55" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Check that X and y have correct shape</span></span>
<span id="cb16-56"><a href="#cb16-56" aria-hidden="true" tabindex="-1"></a>        X, y <span class="op">=</span> check_X_y(X, y)</span>
<span id="cb16-57"><a href="#cb16-57" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb16-58"><a href="#cb16-58" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Store the number of features</span></span>
<span id="cb16-59"><a href="#cb16-59" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n_features_in_ <span class="op">=</span> X.shape[<span class="dv">1</span>]</span>
<span id="cb16-60"><a href="#cb16-60" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb16-61"><a href="#cb16-61" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Store the classes seen during fit</span></span>
<span id="cb16-62"><a href="#cb16-62" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.classes_ <span class="op">=</span> unique_labels(y)</span>
<span id="cb16-63"><a href="#cb16-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-64"><a href="#cb16-64" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.X_ <span class="op">=</span> X</span>
<span id="cb16-65"><a href="#cb16-65" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.y_ <span class="op">=</span> y</span>
<span id="cb16-66"><a href="#cb16-66" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Return the classifier</span></span>
<span id="cb16-67"><a href="#cb16-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span></span>
<span id="cb16-68"><a href="#cb16-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-69"><a href="#cb16-69" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> predict(<span class="va">self</span>, X):</span>
<span id="cb16-70"><a href="#cb16-70" aria-hidden="true" tabindex="-1"></a>        <span class="co">""" A reference implementation of a prediction for a classifier.</span></span>
<span id="cb16-71"><a href="#cb16-71" aria-hidden="true" tabindex="-1"></a><span class="co">        Parameters</span></span>
<span id="cb16-72"><a href="#cb16-72" aria-hidden="true" tabindex="-1"></a><span class="co">        ----------</span></span>
<span id="cb16-73"><a href="#cb16-73" aria-hidden="true" tabindex="-1"></a><span class="co">        X : array-like, shape (n_samples, n_features)</span></span>
<span id="cb16-74"><a href="#cb16-74" aria-hidden="true" tabindex="-1"></a><span class="co">            The input samples.</span></span>
<span id="cb16-75"><a href="#cb16-75" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns</span></span>
<span id="cb16-76"><a href="#cb16-76" aria-hidden="true" tabindex="-1"></a><span class="co">        -------</span></span>
<span id="cb16-77"><a href="#cb16-77" aria-hidden="true" tabindex="-1"></a><span class="co">        y : ndarray, shape (n_samples,)</span></span>
<span id="cb16-78"><a href="#cb16-78" aria-hidden="true" tabindex="-1"></a><span class="co">            The label for each sample is the label of the closest sample</span></span>
<span id="cb16-79"><a href="#cb16-79" aria-hidden="true" tabindex="-1"></a><span class="co">            seen during fit.multiclass.</span></span>
<span id="cb16-80"><a href="#cb16-80" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb16-81"><a href="#cb16-81" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Check is fit had been called</span></span>
<span id="cb16-82"><a href="#cb16-82" aria-hidden="true" tabindex="-1"></a>        check_is_fitted(<span class="va">self</span>, [<span class="st">'X_'</span>, <span class="st">'y_'</span>])</span>
<span id="cb16-83"><a href="#cb16-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-84"><a href="#cb16-84" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Input validation</span></span>
<span id="cb16-85"><a href="#cb16-85" aria-hidden="true" tabindex="-1"></a>        X <span class="op">=</span> check_array(X)</span>
<span id="cb16-86"><a href="#cb16-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-87"><a href="#cb16-87" aria-hidden="true" tabindex="-1"></a>        closest <span class="op">=</span> np.argmin(euclidean_distances(X, <span class="va">self</span>.X_), axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb16-88"><a href="#cb16-88" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.y_[closest]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Bu örnek, regresyon için hazırladığımız örnekten daha karmaşık değil. Uzunluğu, daha ayrıntılı açıklamalar içermesinden kaynaklanıyor. Sizin de kendi sınıflayıcılarınızı yazarken, bu örnekte olduğu gibi, değişkenlerin ne tip olduğu ve ne anlama geldiği, nesne değişkenlerinin (attributes) listesi ve açıklaması, tahminleyicinin kullanımına örnekler, ayrıca <code>fit()</code> ve <code>predict()</code> metodlarının aldığı girdilerin ve döndürdüğü değerlerin açıklamaları gibi bilgileri koymanız gerekir.</p>
<p>Sınıflandırıcılarda hedef değerler ayrık kategorilerdir. Bunlar tam sayı veya dize (string) olarak kullanılmalı. Kategori listesi, <code>classes_</code> isimli sıralanmış bir dizi olarak nesne değişkeni olarak saklanmalıdır.</p>
<p>Verilerin kategorilerini baştan bilmiyorsanız, <code>utils.multiclass.unique_labels()</code> fonksiyonu ile bunları verilerden alabilirsiniz.</p>
<p>Buradaki basit sınıflandırıcı (1-NN) verilen bir tahmin noktasına, eğitim kümesindeki en yakın komşunun değerini atar. Bu yüzden eğitim kümesi kestirim (<code>predict()</code>) adımında erişilebilir olmalıdır. Bu yüzden <code>fit()</code> içinde <code>X_</code> ve <code>y_</code> nesne değişkenleri yaratılır ve bunlar daha sonra <code>predict()</code> içinde tahmin yapmak için kullanılırlar.</p>
<p>Algoritmanın özelliğine bağlı olarak, sınıflandırıcıya <code>decision_function()</code>, <code>predict_proba()</code> ve <code>predict_log_proba()</code> metodları da eklenebilir.</p>
<p>Sınıflandırıcının testlerini yapalım:</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>check_estimator(TemplateClassifier())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Kullanım örneği:</p>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> [[<span class="dv">0</span>, <span class="dv">0</span>], [<span class="dv">1</span>, <span class="dv">1</span>]]</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">1</span>]</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>clf <span class="op">=</span> TemplateClassifier()</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>clf.fit(X, y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="9">
<style>#sk-container-id-1 {color: black;}#sk-container-id-1 pre{padding: 0;}#sk-container-id-1 div.sk-toggleable {background-color: white;}#sk-container-id-1 label.sk-toggleable__label {cursor: pointer;display: block;width: 100%;margin-bottom: 0;padding: 0.3em;box-sizing: border-box;text-align: center;}#sk-container-id-1 label.sk-toggleable__label-arrow:before {content: "▸";float: left;margin-right: 0.25em;color: #696969;}#sk-container-id-1 label.sk-toggleable__label-arrow:hover:before {color: black;}#sk-container-id-1 div.sk-estimator:hover label.sk-toggleable__label-arrow:before {color: black;}#sk-container-id-1 div.sk-toggleable__content {max-height: 0;max-width: 0;overflow: hidden;text-align: left;background-color: #f0f8ff;}#sk-container-id-1 div.sk-toggleable__content pre {margin: 0.2em;color: black;border-radius: 0.25em;background-color: #f0f8ff;}#sk-container-id-1 input.sk-toggleable__control:checked~div.sk-toggleable__content {max-height: 200px;max-width: 100%;overflow: auto;}#sk-container-id-1 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {content: "▾";}#sk-container-id-1 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 input.sk-hidden--visually {border: 0;clip: rect(1px 1px 1px 1px);clip: rect(1px, 1px, 1px, 1px);height: 1px;margin: -1px;overflow: hidden;padding: 0;position: absolute;width: 1px;}#sk-container-id-1 div.sk-estimator {font-family: monospace;background-color: #f0f8ff;border: 1px dotted black;border-radius: 0.25em;box-sizing: border-box;margin-bottom: 0.5em;}#sk-container-id-1 div.sk-estimator:hover {background-color: #d4ebff;}#sk-container-id-1 div.sk-parallel-item::after {content: "";width: 100%;border-bottom: 1px solid gray;flex-grow: 1;}#sk-container-id-1 div.sk-label:hover label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-serial::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: 0;}#sk-container-id-1 div.sk-serial {display: flex;flex-direction: column;align-items: center;background-color: white;padding-right: 0.2em;padding-left: 0.2em;position: relative;}#sk-container-id-1 div.sk-item {position: relative;z-index: 1;}#sk-container-id-1 div.sk-parallel {display: flex;align-items: stretch;justify-content: center;background-color: white;position: relative;}#sk-container-id-1 div.sk-item::before, #sk-container-id-1 div.sk-parallel-item::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: -1;}#sk-container-id-1 div.sk-parallel-item {display: flex;flex-direction: column;z-index: 1;position: relative;background-color: white;}#sk-container-id-1 div.sk-parallel-item:first-child::after {align-self: flex-end;width: 50%;}#sk-container-id-1 div.sk-parallel-item:last-child::after {align-self: flex-start;width: 50%;}#sk-container-id-1 div.sk-parallel-item:only-child::after {width: 0;}#sk-container-id-1 div.sk-dashed-wrapped {border: 1px dashed gray;margin: 0 0.4em 0.5em 0.4em;box-sizing: border-box;padding-bottom: 0.4em;background-color: white;}#sk-container-id-1 div.sk-label label {font-family: monospace;font-weight: bold;display: inline-block;line-height: 1.2em;}#sk-container-id-1 div.sk-label-container {text-align: center;}#sk-container-id-1 div.sk-container {/* jupyter's `normalize.less` sets `[hidden] { display: none; }` but bootstrap.min.css set `[hidden] { display: none !important; }` so we also need the `!important` here to be able to override the default hidden behavior on the sphinx rendered scikit-learn.org. See: https://github.com/scikit-learn/scikit-learn/issues/21755 */display: inline-block !important;position: relative;}#sk-container-id-1 div.sk-text-repr-fallback {display: none;}</style><div id="sk-container-id-1" class="sk-top-container"><div class="sk-text-repr-fallback"><pre>TemplateClassifier()</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br>On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class="sk-container" hidden=""><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-1" type="checkbox" checked=""><label for="sk-estimator-id-1" class="sk-toggleable__label sk-toggleable__label-arrow">TemplateClassifier</label><div class="sk-toggleable__content"><pre>TemplateClassifier()</pre></div></div></div></div></div>
</div>
</div>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>X_test <span class="op">=</span> [[<span class="fl">0.2</span>,<span class="fl">0.2</span>], [<span class="fl">0.4</span>,<span class="fl">0.4</span>], [<span class="fl">0.6</span>, <span class="fl">0.6</span>], [<span class="fl">0.8</span>, <span class="fl">0.8</span>]]</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>y_test <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>]</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>clf.predict(X_test)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="10">
<pre><code>array([0, 0, 1, 1])</code></pre>
</div>
</div>
<p>Modelin doğruluğunu (accuracy) bulmak için <code>score()</code> metodunu kullanabiliriz.</p>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>clf.score(X_test, y_test)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="11">
<pre><code>0.75</code></pre>
</div>
</div>
</section>
<section id="veri-dönüşümü" class="level1 page-columns page-full">
<h1>Veri dönüşümü</h1>
<p><em>Dönüştürücü</em> (transformer) bir veri kümesini alıp başka bir biçime çevirir. Yine bir <code>fit()</code> metodu vardır, ama ardından <code>predict()</code> yerine <code>transform()</code> yapılır.</p>
<section id="hareketli-ortalama" class="level2">
<h2 class="anchored" data-anchor-id="hareketli-ortalama">Hareketli ortalama</h2>
<p>Örnek olarak, verilerin hareketli ortalamasını veren bir dönüştürücü hazırlayalım. Böyle bir işlem için bir dönüştürücü yazmak aşırı gelebilir, ama yararlı olacağı durumlar vardır. Sözgelişi, modelin eğitim kümesini hazırlarken bir adımda hareketli ortalama alıyor olabiliriz. Önceden bu işlemi bir dönüştürücü haline getirirsek, bütün eğitim ve kestirim sürecini bir pipeline içine koymamız, çapraz doğrulamaları aksamadan yapmamız mümkün olur.</p>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.base <span class="im">import</span> BaseEstimator, TransformerMixin</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.utils <span class="im">import</span> check_array</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.utils.validation <span class="im">import</span> check_is_fitted</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> RollingMean(BaseEstimator, TransformerMixin):</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, n<span class="op">=</span><span class="dv">15</span>):</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n <span class="op">=</span> n</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> moving_average_(<span class="va">self</span>, a):</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.convolve(a, np.ones(<span class="va">self</span>.n), <span class="st">"valid"</span>) <span class="op">/</span> <span class="va">self</span>.n</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> fit(<span class="va">self</span>, X, y<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>        X <span class="op">=</span> check_array(X)</span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n_features_in_ <span class="op">=</span> X.shape[<span class="dv">1</span>]</span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> transform(<span class="va">self</span>, X):</span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>        check_is_fitted(<span class="va">self</span>, <span class="st">'n_features_in_'</span>)</span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a>        X <span class="op">=</span> check_array(X)</span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Moving average will have len(X) - n + 1 rows. For consistent size, fill the first n-1 rows with NaN.</span></span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a>        empty_rows <span class="op">=</span> np.array([np.nan]<span class="op">*</span>(X.shape[<span class="dv">1</span>]<span class="op">*</span>(<span class="va">self</span>.n<span class="op">-</span><span class="dv">1</span>))).reshape(<span class="va">self</span>.n<span class="op">-</span><span class="dv">1</span>,X.shape[<span class="dv">1</span>])</span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a>        movav <span class="op">=</span> np.apply_along_axis(<span class="va">self</span>.moving_average_, axis<span class="op">=</span><span class="dv">0</span>, arr<span class="op">=</span>X)</span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.r_[empty_rows, movav]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Bu örnekte <code>fit()</code> herhangi bir işlem yapmıyor, sadece girdi için doğruluk denetimi yapıyor ve <code>n_features_in_</code> nesne özelliğini yaratıyor. Daha sonra <code>transform()</code> çağrıldığında bu değişkenin var olup olmadığı denetleniyor.</p>
<p>Üç değişkenli bir rastgele yürüyüş verisi üretelim:</p>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">29101923</span>)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.cumsum(np.random.rand(<span class="dv">30</span>).reshape(<span class="dv">3</span>,<span class="op">-</span><span class="dv">1</span>).T, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>X</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="13">
<pre><code>array([[0.74977745, 0.96371498, 0.32437245],
       [1.71830174, 1.4121694 , 0.50916844],
       [2.10912041, 1.54142327, 0.77301929],
       [2.12452587, 1.97102509, 1.23124119],
       [2.34991983, 2.00229673, 1.87464155],
       [2.75549879, 2.71351979, 2.71059991],
       [2.87756103, 3.29451338, 3.27770838],
       [3.64506605, 3.47371139, 3.9280419 ],
       [4.18478839, 4.08826894, 4.22898858],
       [5.0129616 , 4.10754193, 4.32410028]])</code></pre>
</div>
</div>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>RollingMean(n<span class="op">=</span><span class="dv">3</span>).fit(X).transform(X)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="14">
<pre><code>array([[       nan,        nan,        nan],
       [       nan,        nan,        nan],
       [1.5257332 , 1.30576922, 0.53552006],
       [1.98398267, 1.64153925, 0.83780964],
       [2.19452204, 1.83824836, 1.29296734],
       [2.40998149, 2.2289472 , 1.93882755],
       [2.66099322, 2.67010996, 2.62098328],
       [3.09270862, 3.16058152, 3.30545006],
       [3.56913849, 3.61883124, 3.81157962],
       [4.28093868, 3.88984076, 4.16037692]])</code></pre>
</div>
</div>
<p>Bu örnekte <code>fit()</code> ayrı bir iş yapmadığı için, aynı işlem doğrudan <code>fit_transform()</code> ile de yapılabilir. Bu metot <code>TransformerMixin</code> sınıfından miras alınır, o yüzden bizim açıkça eklememize lüzum yok.</p>
<div class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>RollingMean(n<span class="op">=</span><span class="dv">3</span>).fit_transform(X)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="15">
<pre><code>array([[       nan,        nan,        nan],
       [       nan,        nan,        nan],
       [1.5257332 , 1.30576922, 0.53552006],
       [1.98398267, 1.64153925, 0.83780964],
       [2.19452204, 1.83824836, 1.29296734],
       [2.40998149, 2.2289472 , 1.93882755],
       [2.66099322, 2.67010996, 2.62098328],
       [3.09270862, 3.16058152, 3.30545006],
       [3.56913849, 3.61883124, 3.81157962],
       [4.28093868, 3.88984076, 4.16037692]])</code></pre>
</div>
</div>
</section>
<section id="minimum-maksimum-ölçekleme" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="minimum-maksimum-ölçekleme">Minimum-maksimum ölçekleme</h2>
<div class="page-columns page-full"><p>Başka bir örnek olarak, minimum-maksimum arası ölçekleme için bir dönüştürücü oluşturalım<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. Bu örnekte <code>fit()</code> metodu boş durmuyor, eğitim kümesinin en büyük ve en küçük değerlerini bulup bir kenara yazıyor.</p><div class="no-row-height column-margin column-container"><li id="fn1"><p><sup>1</sup>&nbsp;Bunun için hazır bir dönüştürücü var ama örnek için yokmuş gibi yapalım.</p></li></div></div>
<div class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MinmaxScaler(BaseEstimator, TransformerMixin):</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> fit(<span class="va">self</span>, X, y<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>        X <span class="op">=</span> check_array(X)</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n_features_in_ <span class="op">=</span> X.shape[<span class="dv">1</span>]</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.max_ <span class="op">=</span> X.<span class="bu">max</span>(axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.min_ <span class="op">=</span> X.<span class="bu">min</span>(axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> transform(<span class="va">self</span>, X):</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>        check_is_fitted(<span class="va">self</span>, <span class="st">"max_"</span>)</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>        X <span class="op">=</span> check_array(X)</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (X <span class="op">-</span> <span class="va">self</span>.min_) <span class="op">/</span> (<span class="va">self</span>.max_ <span class="op">-</span> <span class="va">self</span>.min_)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Burada ölçekleme için herhangi bir parametre alınmadığından başlatıcı <code>__init__</code> boş kalıyor (ama Python sentaksı gereği sınıf tanımında bulunmak zorunda).</p>
<p>Bu dönüştürücünün bir öncekinden farkı, eğitim kümesine bağlı oluşu. Bu ölçekleyici, eğitim verisinin sütunlarının minimum ve maksimum değerlerini belirliyor. <code>transform()</code> işleminde ise, aldığı verileri minimum değer 0 ve maksimum değer 1 olacak şekilde lineer bir fonksiyonla dönüştürüyor.</p>
<p>Bu dönüştürücüyü yine rastgele üretilmiş verilerle deneyelim:</p>
<div class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>X_train <span class="op">=</span> np.random.rand(<span class="dv">20</span>,<span class="dv">3</span>)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>X_test <span class="op">=</span> np.random.rand(<span class="dv">10</span>,<span class="dv">3</span>)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>X_test</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="17">
<pre><code>array([[0.35628925, 0.66850959, 0.84267923],
       [0.69403501, 0.38350617, 0.62806853],
       [0.38789683, 0.53202186, 0.61269947],
       [0.51598942, 0.37764728, 0.36217848],
       [0.02539575, 0.26381172, 0.64366218],
       [0.91755454, 0.36221054, 0.50155528],
       [0.09683517, 0.71776499, 0.7394225 ],
       [0.81163167, 0.49544736, 0.63947337],
       [0.58945327, 0.50590908, 0.03767375],
       [0.09311029, 0.12597857, 0.72295531]])</code></pre>
</div>
</div>
<div class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>scaler <span class="op">=</span> MinmaxScaler().fit(X_train)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>scaler.transform(X_test)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="18">
<pre><code>array([[ 3.42904840e-01,  6.06674521e-01,  8.79083858e-01],
       [ 7.17503869e-01,  2.46825035e-01,  6.44693329e-01],
       [ 3.77961291e-01,  4.34343120e-01,  6.27907771e-01],
       [ 5.20030762e-01,  2.39427514e-01,  3.54297244e-01],
       [-2.40942497e-02,  9.56970773e-02,  6.61724192e-01],
       [ 9.65412838e-01,  2.19936867e-01,  5.06519853e-01],
       [ 5.51403047e-02,  6.68865111e-01,  7.66310361e-01],
       [ 8.47932141e-01,  3.88163622e-01,  6.57149313e-01],
       [ 6.01510650e-01,  4.01372740e-01, -1.15815402e-04],
       [ 5.10089822e-02, -7.83330700e-02,  7.48325452e-01]])</code></pre>
</div>
</div>
<p>Dönüştürücümüz <code>check_estimator</code> testlerinden de başarıyla geçiyor.</p>
<div class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>check_estimator(MinmaxScaler())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="pipeline-kullanımı" class="level1">
<h1>Pipeline kullanımı</h1>
<p>Tahminleyicilerimiz uygun şekilde hazırlandıysa artık bunları model seçimi, parametre arama (grid search), çapraz doğrulama (cross-validation), veri akışı (pipeline) işlemleri için kullanabilirsiniz.</p>
<p>Bir tahminleyiciyi bir veri akışı içinde kullanırken dikkat etmeniz gereken şeyler var:</p>
<ul>
<li>Bir <code>Pipeline</code> nesnesinin <code>fit()</code> metodu, içindeki her tahminleyicinin <code>fit()</code> metodunu sırayla çalıştırır. Hattın bir ucundan giren veriyi dönüştürüp bir sonraki tahminleyiciye aktarır.</li>
<li>Hattın en sonundaki hariç, tahminleyicilerin hepsinin bir <code>fit()</code> veya <code>fit_transform()</code> metodu bulunmalıdır. Eğitim kümesinden farklı bir veri alacaklarsa, <code>transform()</code> metodları olmalıdır.</li>
<li><code>Pipeline</code> nesnesi, hattın son adımındaki tahminleyiciyle aynı metodlara sahiptir. Son tahminleyici bir sınıflandırıcıysa, veri hattı da sınıflandırıcı olarak çalışır. Son aşamada bir dönüştürücü varsa, veri hattı da bir dönüştürücüdür.</li>
</ul>
<p>Veri hatlarıyla ilgili daha fazla bilgi için <a href="https://scikit-learn.org/stable/modules/compose.html#pipeline-chaining-estimators">ilgili belgelere bakabilirsiniz</a>.</p>


</section>


</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>