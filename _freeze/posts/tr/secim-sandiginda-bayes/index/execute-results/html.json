{
  "hash": "736d153ba19dda3f58179295b6b11d05",
  "result": {
    "markdown": "---\ntitle: \"Seçim Sandığında Bayes\"\ndescription: \"Ardışık oy uzunluğuyla sonuç tahmini\"\nauthor: \"Kaan Öztürk\"\ndate: \"6/10/2023\"\nformat: \n  html:\n    code-fold: true\ncategories:\n    - Bayesian analysis\n    - applied probability\nimage : \"secimsandigindabayes_oysayimi.jpg\"\n---\n\n![](secimsandigindabayes_oysayimi.jpg)\n\n28 Mayıs'daki cumhurbaşkanlığı seçiminde oyların sayılmasını izlerken bir şey dikkatimi çekti: Bulunduğum sandıkta Kemal Kılıçdaroğlu'na (KK) arka arkaya çok sayıda oy çıkarken, Recep Tayyip Erdoğan'a (RTE) ardışık olarak ikiden fazla oy çıkmıyordu. Yani bir veya iki oy RTE, ardından KK oyları, ardından bir veya iki RTE oyu, vs.\n\nBunun üzerine aklıma şu soru geldi: Sandıkta bir adayın nihai oy oranını, sayım sırasında o aday için gördüğümüz en uzun ardışık oy uzunluğuna dayanarak (oyların anlık sayısını görmediğimizi varsayarak) tahmin edebilir miyiz? \n\nBu anlamlı bir soru, çünkü o sandıkta adayın (bilinmeyen) oy oranı yüksekse, en uzun zincirin uzunluğu da ona göre artacaktır. Sıfıra yakın bir olasılıksa uzunluk biri aşmayacak, yüzde yüze yakınsa da sayılan oy sayısına yakın olacak.\n\nBu azami zincir uzunluğu kaç oyun sayıldığına da bağlı. Çok çok sayıda oy varsa, büyük sayılar yasası gereği düşük oy oranında bile herhangi bir uzunlukta zincir görmek mümkün. Tersten bakarsak, azami zincir uzunluğunu ikide sabitlemekle, oy sayısı arttıkça oy oranı tahminimiz sıfıra yaklaşmak zorunda kalacak. Sandıklarda sadece birkaç yüz oy olduğu için bu sınırlara yaklaşmayacağız tabii. Yine de bu aşırı durumları akılda tutmak sonuçlarımızı kontrol etmek için yararlı.\n\nSandıkta adayın oy oranına $r$ diyelim. Bunu bilmiyoruz, kestirmek istiyoruz. Sandıkta toplam 352 oy var. Bunların tamamı açıldıktan sonra tahmin edecek bir şey kalmıyor. Belli bir sayıda, mesela 100 oy açıldıktan sonra sonucu tahmin etmek istiyoruz. \n\nİlk aşamada, 100 oy içinde adayın arka arkaya aldığı oy zincirlerinin en uzununun 2 olması olasılığını bulalım.\n\nBu olasılık belki analitik yoldan bulunabilir ama ben yapamadım, o yüzden rastgele sayı üreten kısa bir program yazdım:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code code-fold=\"false\" code-summary=\"importlar ve fonksiyon tanımları\"}\nimport random\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom itertools import groupby\n\ndef oylar_üret(r, oy_sayısı):\n    return random.choices((\"RTE\",\"KK\"), weights=[r, 1-r], k=oy_sayısı)\n\ndef en_uzun_dizi_uzunluğu(x, değer=\"RTE\"):\n    return max(len(list(y)) for c,y in groupby(x) if c==değer)\n    \ndef olabilirlik(r, oy_sayısı, deneme=1000, gözlenen_uzunluk=2):\n    sayaç = 0\n    for i in range(deneme):\n        oylar = oylar_üret(r, oy_sayısı)\n        try:\n            if en_uzun_dizi_uzunluğu(oylar) == gözlenen_uzunluk:\n                sayaç += 1\n        except ValueError: # birinci seçenek hiç gözlenmediyse\n            continue\n    return sayaç / deneme\n```\n:::\n\n\nBirinci fonksiyon `oylar_üret(r, oy_sayısı)` iki adaylı bir seçimde, birinci adayın oy oranı `r` olacak şekilde `oy_sayısı` kadar rastgele oy üretir. İkinci fonksiyon ise, birincinin çıktısını alıp onun içinde ardışık `değer` zincirinin en büyük uzunluğunu bulur.\n\nÖrnek:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code code-fold=\"false\"}\nrandom.seed(20232023)\ns = oylar_üret(r=0.2, oy_sayısı=10)\ns\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n['KK', 'KK', 'KK', 'KK', 'KK', 'KK', 'KK', 'RTE', 'RTE', 'KK']\n```\n:::\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code code-fold=\"false\"}\nen_uzun_dizi_uzunluğu(s, \"RTE\")\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n2\n```\n:::\n:::\n\n\nÜçüncü fonksiyon `olabilirlik`, en uzun dizi uzunluğunun tam 2 olduğu durumların olasılığını, aynı oy oranı ve oy sayısıyla birçok rastgele sandık üreterek kestirir.\n\nÖrneğin, oy oranı 0.2 ise ve 10 adet oy açıldıysa, tam 2 uzunlukta en az bir dizi olması olasılığı yaklaşık 0.22 olur.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code code-fold=\"false\"}\nolabilirlik(0.2, oy_sayısı=10, deneme=10000, gözlenen_uzunluk=2)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n0.2184\n```\n:::\n:::\n\n\nTabii biz asıl oy oranını bilmiyoruz, o yüzden tersten gideceğiz: Farklı oy oranları için, 100 oy içinde tam 2 uzunlukta en az bir dizi görme olabilirliğini hesaplayacağız.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code code-fold=\"true\"}\nr = np.linspace(0, 1, 101)\nL = [olabilirlik(rr, oy_sayısı=100, deneme=100, gözlenen_uzunluk=2) for rr in r]\nplt.plot(r, L)\nplt.xlabel(\"RTE oy oranı\")\nplt.ylabel(\"Olabilirlik\")\nplt.grid()\n```\n\n::: {.cell-output .cell-output-display}\n![Oy oranına göre, iki uzunlukta en az bir dizi görme olasılığı](index_files/figure-html/cell-6-output-1.png){width=589 height=429}\n:::\n:::\n\n\nBu sandıkta, RTE'nin oy oranının olasılık dağılımının 0.5'e doğru neredeyse sıfıra indiğini görüyoruz. Dağılımın tepesi 0.15 değerinde. Dağılım geniş bir aralığa yayılmış olduğu için sonuç hakkında net bir şey söylemek şimdilik zor olsa da, yarıyı geçme şansının çok düşük olduğu anlaşılıyor.\n\n## Bayes formülü\n\nBu noktada biraz duraklayıp bu problemi bir **bayesçi kestirim** alıştırması olarak ifade edelim. Oy oranı $r$ ise ve $G$ gözlemimizi (yani en uzun ardışık zincirin 2 uzunlukta olmasını) temsil ediyorsa, bu gözlem verilmiş olarak oy oranının olasılık dağılımını Bayes formülüyle ifade ederiz:\n\n$$P(r | G) = \\frac{1}{P(G)}P(G|r)P(r)$$\n\n**Önsel inanç:**\nBurada $P(r)$, bir şey gözlemeden önceki oy oranının dağılımıdır. Hiç bir şey gözlemediysek bunu nasıl bilebiliriz? Geçmiş tecrübelerimize dayanarak bir fikrimiz olabilir, veya her şey olabilir diyerek 0-1 arasında düzgün bir dağılım varsayabiliriz. Bu dağılıma _önsel inanç_ (\"prior belief\") denir.\n\n**Olabilirlik:**\n$P(G|r)$ ifadesi, belli bir oy oranı $r$ ile, gözlemimizin olasılığını verir. Yukarıdaki `olabilirlik` fonksiyonu tam bunu yapar. Bu faktörün teknik adı da zaten _olabilirlik_ (\"likelihood\").\n\n_Olabilirlik_ fonksiyonu ile sonuçların nasıl üretildiğine dair _modelimizi_ analizin içine katarız. Mesela burada, iki seçenekten birinin rastgele seçildiği bir Bernoulli modeli kullandık. Başka problemlerde başka modeller kullanılması gerekecektir.\n\nOlabilirlik, aslında aradığımız şeyin tersidir: Parametrelerin bilinen değeriyle çıktılar üretir. Oysa biz bu çıktılardan yola çıkarak parametrenin ne olduğuna dair bir fikir edinmek istiyoruz. Yukarıdaki Bayes formülü bu _ters problemi_ çözmemizi sağlar.\n\n**Normalleştirme:**\n$P(G)$ ifadesi bir _normalleştirme sabitidir_ ve şu şekilde hesaplanabilir:\n$$P(G) = \\sum_{r} P(G|r)P(r)$$\nAma genellikle bu sabiti doğrudan kullanmaya gerek olmaz.\n\n**Sonsal inanç:**\nYukarıdaki faktörleri birleştirerek elde ettiğimiz $P(r|G)$ olasılığına _sonsal inanç_ (\"posterior belief\") denir. Bu, önsel inancımızın eldeki veriyle güncellenerek düzeltilmiş halidir.\n\n## Düzgün önsel ile tahminler\n\nŞimdi bunu problemimize uygulayalım. Düzgün dağılmış bir önsel alalım, yani RTE'nin bu sandıktaki oy oranının 0 ile 1 arasında eşit olasılıkla herhangi bir değerde olabileceğini düşünelim.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code code-fold=\"true\"}\nr = np.linspace(0, 1, 101)\nprior = np.ones_like(r) \nprior /= sum(prior) # normalizasyon\n\n# her oy oranı için olabilirliği hesapla\nL = [olabilirlik(rr, oy_sayısı=100, deneme=100, gözlenen_uzunluk=2) for rr in r]\n\n# her oy oranı için sonsal olasılığı hesapla\nposterior = L*prior\nposterior /= sum(posterior) # normalizasyon\n\nplt.plot(r, prior, label=\"prior\")\nplt.plot(r, posterior, label=\"posterior\")\nplt.xlabel(\"RTE oy oranı\")\nplt.ylabel(\"Yoğunluk\")\nplt.title(\"$P(r|G)$, 100 oy\")\nplt.legend()\nplt.grid()\n```\n\n::: {.cell-output .cell-output-display}\n![Önsel (prior) dağılım ve 100 oyda an az bir tane 2 uzunlukta zincir olabilirliği ile sonsal (posterior) dağılım](index_files/figure-html/cell-7-output-1.png){width=598 height=450}\n:::\n:::\n\n\nÖnceki grafiğin aynısı çıktı, ki sabit bir önsel aldığımız için böyle olması gerek (olabilirliği sabit bir sayıyla çarpıyoruz)\n\nBurada tek bir oy oranı tahmini çıkarmıyoruz. Bayesçi kestirim bize tek tahminler değil, tahmin edilecek değişken için bir olasılık dağılımı verir. İsterseniz bu dağılımdan tek tahminler (point estimate) çıkarabilirsiniz. Örneğin en yüksek olasılıklı değeri 0.15, ortalama değeri 0.17 olarak bulabiliriz.\n\nBaşka bir özet sayı, sonsal dağılımın ortasında %90 alanı kaplayan aralığın (\"highest posterior density interval\") sınırlarıdır. Buna göre RTE'nin oy oranını, %90 olasılıkla (0.06, 0.29) arasında tahmin edebiliriz.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code code-fold=\"true\"}\nprint(f\"En muhtemel değer: { r[np.argmax(posterior)] : .2f}\")\nprint(f\"Ortalama değer: { np.sum(r*posterior): .2f}\")\nprint(f\"%90 yoğunluk aralığı: {r[(0.05<np.cumsum(posterior))][0]}  - {r[(np.cumsum(posterior)<0.95)][-1]}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEn muhtemel değer:  0.14\nOrtalama değer:  0.17\n%90 yoğunluk aralığı: 0.06  - 0.29\n```\n:::\n:::\n\n\n## Güncelleme\n\nDiyelim 100 oy daha sayıldı ve RTE'ye yine en fazla 2 uzunlukta ardışık zincirler gözlediniz. Bu yeni veriyle RTE'nin oy oranına dair inancınızı (sonsal dağılımı) güncelleyebilirsiniz.\n\nBayesci analizin güzel tarafı, bunu yaparken sıfırdan başlamak zorunda olmamanız. Bir önceki adımda bulduğunuz sonsal dağılımı bu sefer önsel dağılım olarak kullanıp aynı işlemi tekrarlayabilirsiniz.\n\nOlabilirlik hesabını tekrarlamak zorunda değilsiniz, çünkü parametreler tamamen aynı olduğu için fonksiyon da aynı olacak.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code code-fold=\"true\"}\nprior = posterior\n\n# her oy oranı için sonsal olasılığı hesapla\nposterior = L*prior\nposterior /= sum(posterior) # normalizasyon\n\nplt.plot(r, prior, label=\"prior\")\nplt.plot(r, posterior, label=\"posterior\")\nplt.xlabel(\"RTE oy oranı\")\nplt.ylabel(\"Yoğunluk\")\nplt.title(\"$P(r|G)$, 200 oy\")\nplt.legend()\nplt.grid()\n\nprint(f\"%90 yoğunluk aralığı: {r[(0.05<np.cumsum(posterior))][0]}  - {r[(np.cumsum(posterior)<0.95)][-1]}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n%90 yoğunluk aralığı: 0.07  - 0.24\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![Yeni veri ile tahmin güncelleme](index_files/figure-html/cell-9-output-2.png){width=598 height=450}\n:::\n:::\n\n\nBu yeni veri ile sonsal dağılım biraz daha daraldı. Güncellemeden sonra %90 yoğunluk aralığı 0.08-0.24 oldu.\n\n## Farklı olabilirlikler\n\nSandıktaki oyların sayımı bittiğinde RTE'nin 352 oydan 83'ünü aldığı görüldü. Yani gerçekleşen oran 0.24 olmuş. Bu değer yukarıda bulduğumuz %90 aralığının tam sınırında. Sonsal dağılımımız olması gerekenin biraz altında kalmış görünüyor.\n\nBunun birkaç sebebi olabilir. Birincisi, ardışık oy dizisi uzunluğu iyi bir gösterge olmayabilir. İkincisi, benim gözlemim yanlış olabilir. Belki başlarda arka arkaya üç tane RTE oyu çıkmıştır da, ben o sırada ardışıklığa dikkat etmediğim için kaçırmış olabilirim.\n\nHesabı bu ihtimale göre iki aşamada tekrarlayalım. İlk 100 oy içinde en uzun RTE zinciri 3 uzunlukta olsun, ondan sonraki 100 oy içinde 2 uzunlukta olsun.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code code-fold=\"true\"}\nprior1 = np.ones_like(r)\nprior1 /= sum(prior1)\n\nL1 = [olabilirlik(rr, oy_sayısı=100, deneme=100, gözlenen_uzunluk=3) for rr in r]\nposterior1 = L1*prior1\nposterior1 /= sum(posterior1) # normalizasyon\n\nprior2 = posterior1\nL2 = [olabilirlik(rr, oy_sayısı=100, deneme=100, gözlenen_uzunluk=2) for rr in r]\nposterior2 = L2*prior2\nposterior2 /= sum(posterior2) # normalizasyon\n\nplt.plot(r, prior1, label=\"prior 1\")\nplt.plot(r, posterior1, label=\"posterior 1 (prior 2)\")\nplt.plot(r, posterior2, label=\"posterior 2\")\nplt.xlabel(\"RTE oy oranı\")\nplt.ylabel(\"Yoğunluk\")\nplt.title(\"$P(r|G)$\")\nplt.legend()\nplt.grid()\n\nprint(f\"%90 yoğunluk aralığı: {r[(0.05<np.cumsum(posterior2))][0]}  - {r[(np.cumsum(posterior2)<0.95)][-1]}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n%90 yoğunluk aralığı: 0.11  - 0.3\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![İlk 100 oy içinde 3 uzunlukta en az bir zincir, ikinci 100 oy içinde 2 uzunlukta en az bir zincir gözlendiğinde sonsal dağılımlar](index_files/figure-html/cell-10-output-2.png){width=598 height=450}\n:::\n:::\n\n\nİlk 100 oyda üçlü diziler olduğu için, birinci sonsal dağılımımız sağa kaymış, yani yüksek oy oranlarının olasılığı artmış. Bunun sonucu olarak da 200 oy gözlendikten sonraki sonsal, bir önceki çözümümüze göre daha sağa kaymış. Böylece %90 yoğunluk aralığı daha geniş ve gerçekleşen oranı içeriyor.\n\n## Farklı önsel: Geçmiş seçimden bilgi aktarma\n\nSon olarak, farklı bir önsel kullanmayı deneyelim. \n\nŞimdiye kadar kullandığımız önsel, bir aday için bütün oy oranlarının eşit olasılıkta olduğunu varsayıyordu.  Oysa bunun doğru olmadığını geçmiş tecrübemizden biliyoruz. Seçimin birinci turunda aynı sandıkta 357 oyun 81'i RTE'ye gittiğini gözlemiştik. Bu bilgiyle, Beta dağılımına uyan bir önsel belirleyebiliriz:\n\n$$P(r) = C\\ r^{81} (1-r)^{276}$$\n\nYine, ilk 100 oyda en uzun zincirin 2 uzunlukta olduğunu varsayarak sonsal hesaplayalım.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code code-fold=\"true\"}\nprior = r**81 * (1-r)**276\nprior /= sum(prior)\n\nL = [olabilirlik(rr, oy_sayısı=100, deneme=100, gözlenen_uzunluk=2) for rr in r]\nposterior = L*prior\nposterior /= sum(posterior)\n\nplt.plot(r, prior, label=\"prior\")\nplt.plot(r, posterior, label=\"posterior\")\nplt.xlabel(\"RTE oy oranı\")\nplt.ylabel(\"Yoğunluk\")\nplt.title(\"$P(r|G)$, 100 oy\")\nplt.legend()\nplt.xlim((0.1,0.4))\nplt.grid()\n\nprint(f\"%90 yoğunluk aralığı: {r[(0.05<np.cumsum(posterior))][0]}  - {r[(np.cumsum(posterior)<0.95)][-1]}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n%90 yoğunluk aralığı: 0.19  - 0.25\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![Geçmiş seçimin oy oranlarıyla oluşturulan önsel ve bununla elde edilen sonsal dağılım.](index_files/figure-html/cell-11-output-2.png){width=621 height=450}\n:::\n:::\n\n\n100 oy sayımında en fazla 2 uzunlukta zincir görmekle, sonsal olasılık dağılımının hafifçe sola kaydığını, yani oy oranının daha düşük ihtimallere kaydığını görüyoruz. \n\nAyrıca, daha belirli (informative) bir önsel seçmekle, sonsal dağılımımızın %90 yoğunluk aralığı daraldı, yani belirsizliği daha az bir sonuç elde ettik.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}